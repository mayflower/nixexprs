From 323caf1e53bb5d029a02289ba4081ed7600196ad Mon Sep 17 00:00:00 2001
From: Maximilian Bosch <maximilian.bosch@mayflower.de>
Date: Fri, 11 Aug 2023 17:23:12 +0000
Subject: [PATCH 1/2] Automatically link social login users against existing
 users by email

This patch is tailored for how authentication works against mailman in
our case. Specifically we have two kinds of users that should be allowed
to authenticate:

* new users that only ever authenticated with OIDC
* existing users that authenticated in the past via LDAP

The first case is trivial: auto-signup kicks in and the user is set up
correctly.

The second isn't: by default, a signup form would be opened, but
this one can't be completed because the username isn't unique. To work
around this, this case is caught early on (by checking if the user
already exists in the database) and then linking the social account
to the existing user and also doing a login rather than processing
with the signup.

In our case this is OK because the logic will only be used in with
our OIDC provider where email addresses are guaranteed to be unique
company-wide.

Both signup and auto-signup immediately return True because that's
the desired behavior and at least the signup check would otherwise
always return false because our mailman has arbitrary signups
disabled.

While it's OK to use emails as identifiers here from a security
perspective because we also control the source, it should be noted
that when a user request to change their name (e.g. after marriage),
the entries in the DB must be fixed up manually (though it's worth
noting that mailman's DB had to be touched in this case already).
---
 allauth/account/utils.py                       |  9 +++++++++
 allauth/socialaccount/adapter.py               |  3 ++-
 allauth/socialaccount/internal/flows/signup.py | 10 +++++++++-
 3 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/allauth/account/utils.py b/allauth/account/utils.py
index cb458e7e..0d0f6cb8 100644
--- a/allauth/account/utils.py
+++ b/allauth/account/utils.py
@@ -297,6 +297,15 @@ def filter_users_by_username(*username):
     return ret
 
 
+def _find_existing_user_by_email(email):
+    """Searches for an existing user by the email and returns the user model."""
+    email_field = app_settings.USER_MODEL_EMAIL_FIELD
+    assert email_field
+    users = get_user_model().objects.filter(**{email_field + "__iexact": email})
+    assert len(users) < 2
+    return users.first()
+
+
 def filter_users_by_email(
     email: str, is_active: Optional[bool] = None, prefer_verified: bool = False
 ) -> List:
diff --git a/allauth/socialaccount/adapter.py b/allauth/socialaccount/adapter.py
index ad03076b..5fb8c515 100644
--- a/allauth/socialaccount/adapter.py
+++ b/allauth/socialaccount/adapter.py
@@ -153,6 +153,7 @@ class DefaultSocialAccountAdapter(BaseAdapter):
         pass
 
     def is_auto_signup_allowed(self, request, sociallogin):
+        return True
         # If email is specified, check for duplicate and if so, no auto signup.
         auto_signup = app_settings.AUTO_SIGNUP
         return auto_signup
@@ -164,7 +165,7 @@ class DefaultSocialAccountAdapter(BaseAdapter):
         Next to simply returning True/False you can also intervene the
         regular flow by raising an ImmediateHttpResponse
         """
-        return get_account_adapter(request).is_open_for_signup(request)
+        return True
 
     def get_signup_form_initial_data(self, sociallogin):
         user = sociallogin.user
diff --git a/allauth/socialaccount/internal/flows/signup.py b/allauth/socialaccount/internal/flows/signup.py
index ea34217c..cf6c47e7 100644
--- a/allauth/socialaccount/internal/flows/signup.py
+++ b/allauth/socialaccount/internal/flows/signup.py
@@ -7,7 +7,7 @@ from allauth.account.internal.flows.signup import (
     complete_signup,
     prevent_enumeration,
 )
-from allauth.account.utils import user_username
+from allauth.account.utils import user_username, _find_existing_user_by_email
 from allauth.core.exceptions import SignupClosedException
 from allauth.core.internal.httpkit import headed_redirect_response
 from allauth.socialaccount import app_settings
@@ -47,6 +47,14 @@ def process_auto_signup(request, sociallogin):
         email = sociallogin.email_addresses[0].email
     # Let's check if auto_signup is really possible...
     if email:
+        # Does the user already exist in database (i.e. was created via LDAP in the past?)
+        if (existing_user := _find_existing_user_by_email(email)) is not None:
+            # when a user (givenname.surname@mayflower.de) exists in the database, it
+            # means that the user was authenticated via LDAP in the past.
+            # That means we link the existing account with this one.
+            sociallogin.connect(request, existing_user)
+            resp = complete_social_signup(request, sociallogin)
+            return True, resp
         assessment = assess_unique_email(email)
         if assessment is True:
             # Auto signup is fine.
